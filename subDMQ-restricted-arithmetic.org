#+PROPERTY: header-args :tangle subDMQ-restricted-arithmetic.thy
* Overview
** Text
- Part of an attempt to reconstruct as much of Zach Weber, _Paradoxes and Inconsistent Mathematics_, CUP 2021 as possible using Isabelle. This file gives the arithmetic developed in the logic subDMQ, original (afaik) to this reconstruction.
- recommended way to view this: in org-mode, view headings down to level 3. That'll show you all the lemma statements but hide the proofs. Gives a nice overview.
- run org-babel-tangle to output a .thy file for Isabelle to check
** Isabelle
#+begin_src isabelle
(* Title: subDMQ-restricted-arithmetic.thy
   Author: Ellie Ripley, https://negation.rocks
,*)


section \<open>Arithmetic in subDMQ\<close>

theory "subDMQ-restricted-arithmetic"
  imports subDMQ "subDMQ-tactics"
begin
#+end_src

* Axiomatization
≤
** Isabelle
#+begin_src isabelle
axiomatization
      num   :: "i ⇒ o"       ("N _" [92] 92)
  and plus  :: "i ⇒ i ⇒ i"   (infixr "+" 80)
  and times :: "i ⇒ i ⇒ i"   (infixr "×" 90)
  and zero  :: "i" ("0")
  and succ  :: "i ⇒ i" ("S _" [95] 95)


lemma normalize_test2: "N x ⊗ N 0 ⇛ x + S 0 = S x ⟹ N 0 ⊗ N x ⇛ x + S 0 = S x"
proof -
  assume prem:"N x \<otimes> N 0 \<Rrightarrow> x + S 0 = S x"
  from prem show ?thesis by(subdmq_clunky_normalize)
qed

axiomatization
  where zero_is_number: "N 0"
    and succ_preserve_number: "N x ⇛ N S x"
    and plus_preserve_number: "N x ⊗ N y ⇛ N (x + y)"
    and times_preserve_number: "N x ⊗ N y ⇛ N (x × y)"
    and succ_inj: "N x ⊗ N y ⇛ S x = S y ⇛ x = y"
    and zero_succ_kaboom: "N x ⇛ 0 = S x ⇛ ⊥"
    and plus_zero: "N x ⇛ x + 0 = x"
    and plus_succ: "N x ⊗ N y ⇛ x + S y = S (x + y)"
    and times_zero: "N x ⇛ x × 0 = 0"
    and times_succ: "N x ⊗ N y ⇛ x × S y = (x × y) + x"
    and induction: "P 0 ⊗ ∀(λx. N x ⇛ P x ⇛ P (S x)) ⇛ ∀(λ y. N y ⇛ P y)"

definition leq :: "i ⇒ i ⇒ o" (infix "≤" 70)
  where "x ≤ y ≡ ∃(λ z. N z ⊗ x + z = y)"

definition sle :: "i ⇒ i ⇒ o" (infix "<" 70)
  where "x < y ≡ ∃(λ z. N z ⊗ x + S z = y)"
#+end_src

* Results
** Some basics
*** lemma induction_rule: "P 0 ⟹ ∀(λ x. N x ⇛ P x ⇛ P (S x)) ⟹ ∀(λ y. N y ⇛ P y)"
#+begin_src isabelle
lemma induction_rule: "P 0 ⟹ ∀(λ x. N x ⇛ P x ⇛ P (S x)) ⟹ ∀(λ y. N y ⇛ P y)"
proof -
  assume zerocase:"P 0" and inductive:"∀(λ x . N x ⇛ P x ⇛ P (S x))"
  from zerocase and inductive have "P 0 ⊗ ∀(λ x . N x ⇛ P x ⇛ P (S x))" ..
  from induction and this show ?thesis ..
qed
#+end_src

*** lemma induction_rule_bare: "P 0 ⟹ ∀(λ x. N x ⇛ P x ⇛ P (S x)) ⟹ N y ⇛ P y"
#+begin_src isabelle
lemma induction_rule_bare: "P 0 ⟹ ∀(λ x. N x ⇛ P x ⇛ P (S x)) ⟹ N y ⇛ P y"
proof -
  assume zerocase:"P 0" and inductive:"∀(λ x. N x ⇛ P x ⇛ P (S x))"
  from zerocase and inductive have "∀(λ y. N y ⇛ P y)" by (rule induction_rule)
  from entl_ui and this show ?thesis ..
qed
#+end_src

*** lemma number_contracts: "N x ⇛ N x ⊗ N x"
#+begin_src isabelle
lemma number_contracts: "N x ⇛ N x ⊗ N x"
proof -
  from zero_is_number and zero_is_number have zerocase:"N 0 ⊗ N 0"..
  { fix z
    from succ_preserve_number and succ_preserve_number have
      "N z ⊗ N z ⇛ N S z ⊗ N S z" by(rule factor_rule)
    from implK and this have
      "N z ⇛ N z ⊗ N z ⇛ N S z ⊗ N S z"..
  }
  have "\<And> z. N z ⇛ N z ⊗ N z ⇛ N S z ⊗ N S z" by fact
  from this have "∀ (λ z. N z ⇛ N z ⊗ N z ⇛ N S z ⊗ N S z)"..
  from zerocase and this show ?thesis by (rule induction_rule_bare)
qed
#+end_src
*** lemma number_contracts3: "N x ⇛ N x ⊗ N x ⊗ N x"
#+begin_src isabelle
lemma number_contracts3: "N x ⇛ N x ⊗ N x ⊗ N x"
proof -
  from implI and number_contracts have "N x ⊗ N x ⇛ N x ⊗ N x ⊗ N x" by(rule factor_rule)
  from number_contracts and this show ?thesis ..
qed
#+end_src
*** lemma number_contracts_succ: "N x ⇛ N x ⊗ N S x"
#+begin_src isabelle
lemma number_contracts_succ: "N x ⇛ N x ⊗ N S x"
proof -
  from implI and succ_preserve_number have "N x ⊗ N x ⇛ N x ⊗ N S x" by(rule factor_rule)
  from number_contracts and this show ?thesis..
qed
#+end_src
*** lemma prop_24: "∀(λ x. N x ⇛ x = 0 ∨ ∃(λ y. x = S y))"
#+begin_src isabelle
lemma prop_24: "∀(λ x. N x ⇛ x = 0 ∨ ∃(λ y. x = S y))"
proof -
  have "0 = 0" by (rule refl)
  from entl_disj_inl and this have zerocase:"0 = 0 ∨ ∃(λ y. 0 = S y)" ..

  { fix z
    have "S z = S z" by (rule refl)
    from entl_eg and this have "∃(λ y. S z = S y)" ..
    from entl_disj_inr and this have "S z = 0 ∨ ∃(λ y. S z = S y)" ..
    from implK and this have "z = 0 ∨ ∃(λ y. z = S y) ⇛ S z = 0 ∨ ∃(λ y. S z = S y)" ..
    from implK and this have "N z ⇛ z = 0 ∨ ∃(λ y. z = S y) ⇛ S z = 0 ∨ ∃(λ y. S z = S y)" ..
  }
  have "\<And>z. N z ⇛ z = 0 ∨ ∃(λ y. z = S y) ⇛ S z = 0 ∨ ∃(λ y. S z = S y)" by fact
  then have inductive: "∀(λ z. N z ⇛ z = 0 ∨ ∃(λ y. z = S y) ⇛ S z = 0 ∨ ∃(λ y. S z = S y))" ..

  from zerocase and inductive show ?thesis by (rule induction_rule)
qed
#+end_src
** Addition
*** lemma plus_zero': "N x ⇛ 0 + x = x"
#+begin_src isabelle
lemma plus_zero': "N x ⇛ 0 + x = x"
proof -
  { fix z
    have "0 + z = z ⇛ S(0 + z) = S z" by (rule eqsub_context)
    from plus_succ and this have "N 0 ⊗ N z ⇛ 0 + z = z ⇛ 0 + S z = S z" by (rule eqsub_rule'_dt)
    from conj_export and this have "N 0 ⇛ N z ⇛ 0 + z = z ⇛ 0 + S z = S z"..
    from this and zero_is_number have "N z ⇛ 0 + z = z ⇛ 0 + S z = S z"..
  }
  have "\<And> z. N z ⇛ 0 + z = z ⇛ 0 + S z = S z" by fact
  then have inductive: "∀(λ z. N z ⇛ 0 + z = z ⇛ 0 + S z = S z)" ..

  from plus_zero and zero_is_number have "0 + 0 = 0"..
  from this and inductive show ?thesis by (rule induction_rule_bare)
qed
#+end_src

*** lemma plus_comm_aux: "N x ⊗ N y ⇛ x + S y = S x + y"
#+begin_src isabelle
lemma plus_comm_aux: "N x ⊗ N y ⇛ x + S y = S x + y"
proof -
  from plus_zero and plus_succ have "N x ⇛ N x ⊗ N 0 ⇛ x + S 0 = S x" by(rule eqsub_rule_dt)
  from conj_import and this have "N x ⊗ N x ⊗ N 0 ⇛ x + S 0 = S x"..
  from this have "N 0 ⊗ N x ⊗ N x ⇛ x + S 0 = S x" by (subdmq_clunky_normalize)
  (* TODO: this works with clunky, but not without---why? *)
  from conj_export and this have "N 0 ⇛ N x ⊗ N x ⇛ x + S 0 = S x"..
  from this and zero_is_number have "N x ⊗ N x ⇛ x + S 0 = S x"..
  from plus_zero and this have "N S x ⇛ N x ⊗ N x ⇛ x + S 0 = S x + 0" by(rule eqsub_rule'_dt)
  from succ_preserve_number and this have "N x ⇛ N x ⊗ N x ⇛ x + S 0 = S x + 0"..
  from conj_import and this have "N x ⊗ N x ⊗ N x ⇛ x + S 0 = S x + 0"..
  from number_contracts3 and this have zerocase:"N x ⇛ x + S 0 = S x + 0"..

  { fix z
    have "(N x ⇛ x + S z = S x + z) ⇛ N x ⇛ S (x + S z) = S (S x + z)"
      by(rule eqsub_context_dt)
    from implC and this have
      "N x ⇛ (N x ⇛ x + S z = S x + z) ⇛ S (x + S z) = S (S x + z)"..
    from plus_succ and this have
      "N x ⊗ N S z ⇛ N x ⇛ (N x ⇛ x + S z = S x + z) ⇛ x + S S z = S (S x + z)"
      by(rule eqsub_rule'_dt)
    from conj_import and this have
      "(N x ⊗ N S z) ⊗ N x ⇛ (N x ⇛ x + S z = S x + z) ⇛ x + S S z = S (S x + z)"..
    from plus_succ and this have
      "N S x ⊗ N z ⇛ (N x ⊗ N S z) ⊗ N x ⇛ (N x ⇛ x + S z = S x + z) ⇛ x + S S z = S x + S z"
      by(rule eqsub_rule'_dt)
    from conj_import and this have
      ready:"(N S x ⊗ N z) ⊗ (N x ⊗ N S z) ⊗ N x ⇛ (N x ⇛ x + S z = S x + z) ⇛ x + S S z = S x + S z"..

    from number_contracts_succ and number_contracts_succ have
      "N x ⊗ N z ⇛ (N x ⊗ N S x) ⊗ (N z ⊗ N S z)" by(rule factor_rule)
    from implI and this have
      "N x ⊗ N x ⊗ N z ⇛ N x ⊗ (N x ⊗ N S x) ⊗ (N z ⊗ N S z)" by(rule factor_rule)
    from this have
      ready2:"N z ⊗ (N x ⊗ N x) ⇛ (N S x ⊗ N z) ⊗ (N x ⊗ N S z) ⊗ N x"
      by(subdmq_clunky_normalize)

    from implI and number_contracts have
      "N z ⊗ N x ⇛ N z ⊗ (N x ⊗ N x)" by (rule factor_rule)
    from this and ready2 have
      "N z ⊗ N x ⇛ (N S x ⊗ N z) ⊗ (N x ⊗ N S z) ⊗ N x"..

    from this and ready have
      "N z ⊗ N x ⇛ (N x ⇛ x + S z = S x + z) ⇛ x + S S z = S x + S z"..
    from conj_export and this have
      "N z ⇛ N x ⇛ (N x ⇛ x + S z = S x + z) ⇛ x + S S z = S x + S z"..
    from this and implC have
      "N z ⇛ (N x ⇛ x + S z = S x + z) ⇛ N x ⇛ x + S S z = S x + S z"..
  }
  have "\<And>z. N z ⇛ (N x ⇛ x + S z = S x + z) ⇛ N x ⇛ x + S S z = S x + S z" by fact
  then have
    inductive:"∀(λ z. N z ⇛ (N x ⇛ x + S z = S x + z) ⇛ N x ⇛ x + S S z = S x + S z)" ..

  from zerocase and inductive have "N y ⇛ N x ⇛ x + S y = S x + y" by(rule induction_rule_bare)
  from conj_import and this have "N y ⊗ N x ⇛ x + S y = S x + y"..
  then show ?thesis by(subdmq_clunky_normalize)
qed
#+end_src

*** lemma plus_comm: "x + y = y + x"
#+begin_src isabelle
lemma plus_comm: "x + y = y + x"
proof -
  from plus_zero and plus_zero' have zerocase: "0 + y = y + 0"
    by(rule eqsub_rule')
  { fix z
    have "z + y = y + z ⇛ S (z + y) = S (y + z)"
      by(rule eqsub_context)
    from plus_succ and this have "z + y = y + z ⇛ S (z + y) = y + S z"
      by(rule eqsub_rule')
    from plus_succ and this have "z + y = y + z ⇛ z + S y = y + S z"
      by(rule eqsub_rule')
    from plus_comm_aux and this have "z + y = y + z ⇛ S z + y = y + S z"
      by(rule eqsub_rule)
  }
  have "\<And> z. z + y = y + z ⇛ S z + y = y + S z" by fact
  then have inductive:"∀(λ z. z + y = y + z ⇛ S z + y = y + S z)" ..

  from zerocase and inductive show ?thesis by(rule induction_rule_bare)
qed
#+end_src

*** lemma plus_ass: "x + y + z = (x + y) + z"
#+begin_src isabelle
lemma plus_ass: "x + y + z = (x + y) + z"
proof -
  from plus_zero[of y] and plus_zero have "(x + y) + 0 = x + y + 0"
    by(rule eqsub_rule)
  from eq_sym_impl and this have zerocase:"x + y + 0 = (x + y) + 0" ..

  { fix z
    have "x + y + z = (x + y) + z ⇛ S (x + y + z) = S((x + y) + z)"
      by(rule eqsub_context)
    then have "x + y + z = (x + y) + z ⇛ x + y + S z = (x + y) + S z"
      apply -
      apply (rule eqsub_rule'[OF plus_succ])
      apply (rule eqsub_rule'[OF plus_succ])
      apply (rule eqsub_rule'[OF plus_succ])
      apply assumption
      done
  }
  have "\<And> z. x + y + z = (x + y) + z ⇛ x + y + S z = (x + y) + S z" by fact
  then have inductive:"∀(λ z. x + y + z = (x + y) + z ⇛ x + y + S z = (x + y) + S z)" ..

  from zerocase and inductive show ?thesis by (rule induction_rule_bare)
qed
#+end_src

*** lemma plus_cancel: "x + z = y + z ⇛ x = y"
#+begin_src isabelle
lemma plus_cancel: "x + z = y + z ⇛ x = y"
proof -
  from implI have "x + 0 = y + 0 ⇛ x + 0 = y"
    by(rule eqsub_rule[OF plus_zero])
  then have zerocase: "x + 0 = y + 0 ⇛ x = y"
    by(rule eqsub_rule[OF plus_zero])

  { fix w

    let ?ih = \<open>x + S w = y + S w\<close>

    from plus_succ and implI have "?ih ⇛ S(x + w) = y + S w" by (rule eqsub_rule)
    from plus_succ and this have "?ih ⇛ S(x + w) = S(y + w)" by (rule eqsub_rule)
    from this and succ_inj have "?ih ⇛ x + w = y + w" ..
    from implB and this have "(x + w = y + w ⇛ x = y) ⇛ ?ih ⇛ x = y" ..
  }
  have "\<And> w. (x + w = y + w ⇛ x = y) ⇛ x + S w = y + S w ⇛ x = y" by fact
  then have inductive:"∀(λ w.((x + w = y + w ⇛ x = y) ⇛ x + S w = y + S w ⇛ x = y))" ..

  from zerocase and inductive show ?thesis by(rule induction_rule_bare)
qed
#+end_src

*** lemma plus_cancel_zero: "x + n = x ⇛ n = 0"
#+begin_src isabelle
lemma plus_cancel_zero: "x + n = x ⇛ n = 0"
proof -
  from plus_cancel have "n + x = x ⇛ n = 0" by(rule eqsub_rule[OF plus_zero'])
  then show ?thesis by (rule eqsub_rule[OF plus_comm])
qed
#+end_src

(* this is proved by induction on p195; quicker by substitution *)
*** lemma plus_eq_insert: "x = y ⇛ x + z = y + z"
#+begin_src isabelle
lemma plus_eq_insert: "x = y ⇛ x + z = y + z"
proof -
  show ?thesis by (rule eqsub_context)
qed
#+end_src

** Multiplication
*** lemma times_zero': "0 × x = 0"
#+begin_src isabelle
lemma times_zero': "0 × x = 0"
proof -
  { fix z
    from plus_zero and implI have "0 × z = 0 ⇛ 0 × z + 0 = 0 " by(rule eqsub_rule)
    from times_succ and this have "0 × z = 0 ⇛ 0 × S z = 0" by (rule eqsub_rule')
  }
  have "\<And> z. 0 × z = 0 ⇛ 0 × S z = 0" by fact
  then have inductive:"∀ (λz. 0 × z = 0 ⇛ 0 × S z = 0)" ..

  from times_zero and inductive show ?thesis by(rule induction_rule_bare)
qed
#+end_src

*** lemma times_one: "x × S 0 = x"
#+begin_src isabelle
lemma times_one: "x × S 0 = x"
proof -
  from times_zero and times_succ have "x × S 0 = 0 + x" by (rule eqsub_rule)
  from plus_zero' and this show ?thesis by(rule eqsub_rule)
qed
#+end_src


*** lemma times_succ': "S x × y = (x × y) + y"
#+begin_src isabelle
lemma times_succ': "S x × y = (x × y) + y"
proof -
  from plus_zero and times_zero have "(x × 0) + 0 = 0" by (rule eqsub_rule')
  from this and times_zero have zerocase:"S x × 0 = (x × 0) + 0" by (rule eqsub_rule')

  { fix y
    from times_succ have "S x × y = (x × y) + y ⇛ S x × S y = ((x × y) + y) + S x"
      by(rule equals_left_rule)
    then have "S x × y = (x × y) + y ⇛ S x × S y = (x × y) + y + S x"
      by(rule eqsub_rule'[OF plus_ass])
    then have "S x × y = (x × y) + y ⇛ S x × S y = (x × y) + S y + x"
      by(rule eqsub_rule[OF plus_comm_aux])
    then have "S x × y = (x × y) + y ⇛ S x × S y = (x × y) + x + S y"
      by(rule eqsub_rule[OF plus_comm])
    then have "S x × y = (x × y) + y ⇛ S x × S y = ((x × y) + x) + S y"
      by(rule eqsub_rule[OF plus_ass])
    then have "S x × y = (x × y) + y ⇛ S x × S y = (x × S y) + S y"
      by(rule eqsub_rule'[OF times_succ])
  }
  have "\<And> y. S x × y = (x × y) + y ⇛ S x × S y = (x × S y) + S y" by fact
  then have inductive: "∀ (λy. S x × y = (x × y) + y ⇛ S x × S y = (x × S y) + S y)" ..

  from zerocase and inductive show ?thesis by (rule induction_rule_bare)
qed
#+end_src

*** lemma times_comm: "x × y = y × x"
#+begin_src isabelle
lemma times_comm: "x × y = y × x"
proof -

  from times_zero' have zerocase:"0 × y = y × 0"
    by(rule eqsub_rule'[OF times_zero])

  { fix x
    have "x × y = y × x ⇛ (x × y) + y = (y × x) + y"
      by(rule eqsub_context)
    then have "x × y = y × x ⇛ S x × y = (y × x) + y"
      by(rule eqsub_rule'[OF times_succ'])
    then have "x × y = y × x ⇛ S x × y = y × S x"
      by(rule eqsub_rule'[OF times_succ])
  }
  have "\<And>x . x × y = y × x ⇛ S x × y = y × S x" by fact
  then have inductive: "∀ (λ x. x × y = y × x ⇛ S x × y = y × S x)" ..

  from zerocase and inductive show ?thesis by (rule induction_rule_bare)
qed
#+end_src

*** lemma times_plus_dist: "x × (y + z) = (x × y) + (x × z)"
#+begin_src isabelle
lemma times_plus_dist: "x × (y + z) = (x × y) + (x × z)"
proof -
  from times_zero' have "0 × (y + z) = 0 + 0"
    by(rule eqsub_rule'[OF plus_zero])
  then have "0 × (y + z) = (0 × y) + 0"
    by(rule eqsub_rule'[OF times_zero'])
  then have zerocase:"0 × (y + z) = (0 × y) + (0 × z)"
    by(rule eqsub_rule'[OF times_zero'])

  { fix x
    have "x × (y + z) = (x × y) + (x × z) ⇛ (x × (y + z)) + y + z = ((x × y) + (x × z)) + y + z"
      by(rule eqsub_context)
    then have "x × (y + z) = (x × y) + (x × z) ⇛ S x × (y + z) = ((x × y) + (x × z)) + y + z"
      by(rule eqsub_rule'[OF times_succ'])
    then have "x × (y + z) = (x × y) + (x × z) ⇛ S x × (y + z) = (x × y) + (x × z) + y + z"
      by(rule eqsub_rule'[OF plus_ass])
    then have "x × (y + z) = (x × y) + (x × z) ⇛ S x × (y + z) = (x × y) + (x × z) + z + y"
      by(rule eqsub_rule[OF plus_comm])
    then have "x × (y + z) = (x × y) + (x × z) ⇛ S x × (y + z) = (x × y) + ((x × z) + z) + y"
      by(rule eqsub_rule[OF plus_ass])
    then have "x × (y + z) = (x × y) + (x × z) ⇛ S x × (y + z) = (x × y) + y + ((x × z) + z)"
      by(rule eqsub_rule[OF plus_comm])
    then have "x × (y + z) = (x × y) + (x × z) ⇛ S x × (y + z) = ((x × y) + y) + ((x × z) + z)"
      by(rule eqsub_rule[OF plus_ass])
    then have "x × (y + z) = (x × y) + (x × z) ⇛ S x × (y + z) = (S x × y) + ((x × z) + z)"
      by(rule eqsub_rule'[OF times_succ'])
    then have "x × (y + z) = (x × y) + (x × z) ⇛ S x × (y + z) = (S x × y) + (S x × z)"
      by(rule eqsub_rule'[OF times_succ'])
  }
  have "\<And> x. x × (y + z) = (x × y) + (x × z) ⇛ S x × (y + z) = (S x × y) + (S x × z)" by fact
  then have inductive: "∀(λ x.  x × (y + z) = (x × y) + (x × z) ⇛ S x × (y + z) = (S x × y) + (S x × z))" ..

  from zerocase and inductive show ?thesis by (rule induction_rule_bare)
qed
#+end_src

*** lemma times_plus_dist': "(y + z) × x = (y × x) + (z × x)"
#+begin_src isabelle
lemma times_plus_dist': "(y + z) × x = (y × x) + (z × x)"
  apply (rule eqsub_rule[OF times_comm[of x y]])
  apply (rule eqsub_rule[OF times_comm[of x z]])
  apply (rule eqsub_rule[OF times_comm[of x "(y + z)"]])
  apply (rule times_plus_dist)
  done
#+end_src
*** lemma times_ass: "x × y × z = (x × y) × z"
#+begin_src isabelle
lemma times_ass: "x × y × z = (x × y) × z"
proof -
  from times_zero have "x × 0 = (x × y) × 0"
    by(rule eqsub_rule'[OF times_zero])
  then have zerocase:"x × y × 0 = (x × y) × 0"
    by(rule eqsub_rule'[OF times_zero])

  { fix z
    have "x × y × z = (x × y) × z ⇛ (x × y × z) + (x × y) = ((x × y) × z) + (x × y)"
      by(rule eqsub_context)
    then have "x × y × z = (x × y) × z ⇛ (x × y × z) + (x × y) = (x × y) × S z"
      by(rule eqsub_rule'[OF times_succ])
    then have "x × y × z = (x × y) × z ⇛ x × ((y × z) + y) = (x × y) × S z"
      by(rule eqsub_rule'[OF times_plus_dist])
    then have "x × y × z = (x × y) × z ⇛ x × y × S z = (x × y) × S z"
      by(rule eqsub_rule'[OF times_succ])
  }
  have "\<And> z. x × y × z = (x × y) × z ⇛ x × y × S z = (x × y) × S z" by fact
  then have inductive: "∀(λ z. x × y × z = (x × y) × z ⇛ x × y × S z = (x × y) × S z)" ..

  from zerocase and inductive show ?thesis by (rule induction_rule_bare)
qed
#+end_src

** Ordering
*** lemma sle_leq: "x < y ⇛ x ≤ y"
#+begin_src isabelle
lemma sle_leq: "x < y ⇛ x ≤ y"
proof -
  { fix n
    from implI and impl_eg have "x + S n = y ⇛ ∃(λz . x + z = y)" ..
  }
  have "\<And> n . x + S n = y ⇛ ∃(λ z . x + z = y)" by fact
  then have "∀(λ n . x + S n = y ⇛ ∃(λ z . x + z = y))" ..
  from all_ante and this show ?thesis
    unfolding leq_def
    unfolding sle_def ..
qed
#+end_src

*** lemma plus_zero_sub: "x + n = y ⊗ n = 0 ⇛ x = y"
#+begin_src isabelle
lemma plus_zero_sub: "x + n = y ⊗ n = 0 ⇛ x = y"
proof -
  from plus_zero have "0 = n ⇛ x + n = x" by (rule equals_left_rule)
  then have step1:"n = 0 ⇛ x + n = x" by (rule bisub_rule[OF eq_sym_bientl])

  from implI have "x + n = x ⇛ x + n = y ⇛ x = y" by(rule equals_left_rule)
  from step1 and this have "n = 0 ⇛ x + n = y ⇛ x = y" ..
  from conj_import and this have "n = 0 ⊗ x + n = y ⇛ x = y" ..
  then show ?thesis
    by (subdmq_normalize)
qed
#+end_src

*** lemma plus_succ_sle_sub: "x + n = y ⊗ ∃(λz. n = S z) ⇛ x < y"
#+begin_src isabelle
lemma plus_succ_sle_sub: "x + n = y ⊗ ∃(λz. n = S z) ⇛ x < y"
proof -
  { fix z
    from implI and impl_eg have "x + S z = y ⇛ x < y"
      unfolding sle_def ..
    then have "S z = n ⇛ x + n = y ⇛ x < y" by (rule equals_left_rule)
    then have "n = S z ⇛ x + n = y ⇛ x < y" by (rule bisub_rule[OF eq_sym_bientl])
  }
  have "\<And> z . n = S z ⇛ x + n = y ⇛ x < y" by fact
  then have "∀ (λ z. n = S z ⇛ x + n = y ⇛ x < y)" ..
  from all_ante and this have "∃(λ z . n = S z) ⇛ x + n = y ⇛ x < y" ..
  from conj_import and this have "∃(λ z . n = S z) ⊗ x + n = y ⇛ x < y" ..
  then show ?thesis by (rule bisub_rule[OF conj_bicomm])
qed
#+end_src

*** lemma leq_eq_or_sle: "x ≤ y ⇛ x = y ∨ x < y"
#+begin_src isabelle
lemma leq_eq_or_sle: "x ≤ y ⇛ x = y ∨ x < y"
proof -
  { fix n
    from impl_conj_in and prop_24 have
      "(x + n = y) ⇛ ∀(λ m. m = 0 ∨ ∃(λ z. m = S z)) ⊗ x + n = y" ..
    then have step1:"(x + n = y) ⇛ x + n = y ⊗ ∀(λ m. m = 0 ∨ ∃(λ z. m = S z))"
      by(rule bisub_rule[OF conj_bicomm])
    from impl_ui have
      "x + n = y ⊗ ∀(λ m. m = 0 ∨ ∃(λ z. m = S z)) ⇛ x + n = y ⊗ (n = 0 ∨ ∃(λ z. n = S z))"
      by(rule conj_monotone_right_rule)
    from step1 and this have "(x + n = y) ⇛ x + n = y ⊗ (n = 0 ∨ ∃(λ z. n = S z))" ..
    from this and dist_cd_ltr have
      step1:"(x + n = y) ⇛ (x + n = y ⊗ n = 0) ∨ (x + n = y ⊗ ∃(λ z. n = S z))" ..

    from plus_zero_sub and impl_disj_inl have lefthorn:"x + n = y ⊗ n = 0 ⇛ x = y ∨ x < y" ..
    from plus_succ_sle_sub and impl_disj_inr have
      righthorn:"x + n = y ⊗ ∃(λ z . n = S z) ⇛ x = y ∨ x < y" ..
    from lefthorn and righthorn have
      "(x + n = y ⊗ n = 0) ∨ (x + n = y ⊗ ∃(λ z. n = S z)) ⇛ x = y ∨ x < y"
      by (rule disj_left_rule)
    from step1 and this have "x + n = y ⇛ x = y ∨ x < y" ..
  }
  have "\<And> n . x + n = y ⇛ x = y ∨ x < y" by fact
  then have "∀(λ n . x + n = y ⇛ x = y ∨ x < y)" ..
  from all_ante and this show ?thesis
    unfolding leq_def ..
qed
#+end_src

*** lemma zero_leq: "0 ≤ x"
#+begin_src isabelle
lemma zero_leq: "0 ≤ x"
proof -
  from entl_eg and plus_zero' show ?thesis
    unfolding leq_def ..
qed
#+end_src

*** lemma zero_succ_sle: "0 < S x"
#+begin_src isabelle
lemma zero_succ_sle: "0 < S x"
proof -
  from entl_eg and plus_zero' show ?thesis
    unfolding sle_def ..
qed
#+end_src

*** lemma sle_zero_kaboom: "x < 0 ⇛ ⊥"
#+begin_src isabelle
lemma sle_zero_kaboom: "x < 0 ⇛ ⊥"
proof -
  { fix n
    from zero_succ_kaboom have "S (x + n) = 0 ⇛ ⊥"
      by (rule bisub_rule[OF eq_sym_bientl])
    then have "x + S n = 0 ⇛ ⊥"
      by (rule eqsub_rule'[OF plus_succ])
  }
  have "\<And> n . x + S n = 0 ⇛ ⊥" by fact
  then have "∀ (λ n . x + S n = 0 ⇛ ⊥)" ..
  from all_ante and this show ?thesis
    unfolding sle_def ..
qed
#+end_src

*** lemma leq_plus: "x ≤ x + y"
#+begin_src isabelle
lemma leq_plus: "x ≤ x + y"
proof -
  from entl_eg and refl show ?thesis
    unfolding leq_def ..
qed
#+end_src

*** lemma sle_plus_succ: "x < x + S y"
#+begin_src isabelle
lemma sle_plus_succ: "x < x + S y"
proof -
  from entl_eg and refl show ?thesis
    unfolding sle_def ..
qed
#+end_src

*** lemma sle_succ: "x < S x"
#+begin_src isabelle
lemma sle_succ: "x < S x"
proof -
  from plus_succ have "x + S 0 = S x" by(rule eqsub_rule[OF plus_zero])
  from entl_eg and this show ?thesis
    unfolding sle_def ..
qed
#+end_src

*** lemma leq_refl: "x ≤ x"
#+begin_src isabelle
lemma leq_refl: "x ≤ x"
proof -
  from entl_eg and plus_zero show ?thesis
    unfolding leq_def ..
qed
#+end_src

*** lemma sle_antisymm_kaboom: "x < y ⊗ y < x ⇛ ⊥"
#+begin_src isabelle
lemma sle_antisymm_kaboom: "x < y ⊗ y < x ⇛ ⊥"
proof -
  { fix m
    { fix n
      from implI have "x + S n = y ⇛ y + S m = x ⇛ (x + S n) + S m = x" by(rule equals_left_rule)
      then have "x + S n = y ⇛ y + S m = x ⇛ x + S n + S m = x" by (rule eqsub_rule'[OF plus_ass])
      from conj_import and this have "x + S n = y ⊗ y + S m = x ⇛ x + S n + S m = x" ..
      from this and plus_cancel_zero have "x + S n = y ⊗ y + S m = x ⇛ S n + S m = 0" ..
      then have "x + S n = y ⊗ y + S m = x ⇛ S(S n + m) = 0" by(rule eqsub_rule[OF plus_succ])
      then have "x + S n = y ⊗ y + S m = x ⇛ 0 = S(S n + m)" by(rule bisub_rule[OF eq_sym_bientl])
      from this zero_succ_kaboom have "x + S n = y ⊗ y + S m = x ⇛ ⊥" ..
      from conj_export and this have "x + S n = y ⇛ y + S m = x ⇛ ⊥" ..
    }
    have "\<And> n . x + S n = y ⇛ y + S m = x ⇛ ⊥" by fact
    then have "∀ (λ n . x + S n = y ⇛ y + S m = x ⇛ ⊥)" ..
    from all_ante and this have
      "x < y ⇛ y + S m = x ⇛ ⊥"
      unfolding sle_def ..
  }
  have "\<And> m . x < y ⇛ y + S m = x ⇛ ⊥" by fact
  then have "∀ (λ m . x < y ⇛ y + S m = x ⇛ ⊥)" ..
  from all_cons and this have
    "x < y ⇛ ∀ (λ m . y + S m = x ⇛ ⊥)" ..
  from this and all_ante have
    "x < y ⇛ y < x ⇛ ⊥"
    unfolding sle_def ..
  from conj_import and this show ?thesis ..
qed
#+end_src

*** lemma leq_antisymm: "x ≤ y ⊗ y ≤ x ⇛ x = y"
#+begin_src isabelle
lemma leq_antisymm: "x ≤ y ⊗ y ≤ x ⇛ x = y"
proof -
  from implI have case1:"x + 0 = y ⇛ x = y" by(rule eqsub_rule'[OF plus_zero])
  from implI have "y + 0 = x ⇛ y = x" by(rule eqsub_rule'[OF plus_zero])
  then have case2: "y + 0 = x ⇛ x = y" by(rule bisub_rule[OF eq_sym_bientl])

  from leq_eq_or_sle and leq_eq_or_sle have
    "x ≤ y ⊗ y ≤ x ⇛ (x = y ∨ x < y) ⊗ (y = x ∨ y < x)" by(rule factor_rule)
  from this and double_dist have
    step1:"x ≤ y ⊗ y ≤ x ⇛ x = y ∨ y = x ∨ (x < y ⊗ y < x)" ..

  from implI have step2:"y = x ⇛ x = y" by(rule bisub_rule[OF eq_sym_bientl])
  from sle_antisymm_kaboom and efq_impl have "x < y ⊗ y < x ⇛ x = y" ..
  from step2 and this have
    "y = x ∨ (x < y ⊗ y < x) ⇛ x = y" by (rule disj_left_rule)
  from implI and this have
    "x = y ∨ y = x ∨ (x < y ⊗ y < x) ⇛ x = y" by (rule disj_left_rule)
  from step1 and this show ?thesis ..
qed
#+end_src

*** lemma leq_trans: "x ≤ y ⊗ y ≤ z ⇛ x ≤ z"
#+begin_src isabelle
lemma leq_trans: "x ≤ y ⊗ y ≤ z ⇛ x ≤ z"
proof -
  { fix m
    { fix n
      from implI have
        "x + n = y ⇛ y + m = z ⇛ (x + n) + m = z" by (rule equals_left_rule)
      then have
        "x + n = y ⇛ y + m = z ⇛ x + n + m = z" by (rule eqsub_rule'[OF plus_ass])
      from impl_eg and this have
        "x + n = y ⇛ y + m = z ⇛ x ≤ z"
        unfolding leq_def
        by(rule impl_link_121)
    }
    have "\<And> n . x + n = y ⇛ y + m = z ⇛ x ≤ z" by fact
    then have "∀ (λ n . x + n = y ⇛ y + m = z ⇛ x ≤ z)" ..
    from all_ante and this have
      "x ≤ y ⇛ y + m = z ⇛ x ≤ z"
      unfolding leq_def ..
  }
  have "\<And> m . x ≤ y ⇛ y + m = z ⇛ x ≤ z" by fact
  then have "∀ (λ m . x ≤ y ⇛ y + m = z ⇛ x ≤ z)" ..
  from all_cons and this have
    "x ≤ y ⇛ ∀ (λ m . y + m = z ⇛ x ≤ z)" ..
  from this and all_ante have
    "x ≤ y ⇛ y ≤ z ⇛ x ≤ z"
    unfolding leq_def ..
  from conj_import and this show ?thesis ..
qed
#+end_src

(* this is proved by induction (p198), but doesn't need to be;
   see also mention on p199, which seems to take induction to be important here
*)
*** lemma sle_refl_kaboom: "x < x ⇛ ⊥"
#+begin_src isabelle
lemma sle_refl_kaboom: "x < x ⇛ ⊥"
proof -
  { fix n
    from plus_cancel_zero have "x + S n = x ⇛ 0 = S n" by(rule bisub_rule[OF eq_sym_bientl])
    from this and zero_succ_kaboom have "x + S n = x ⇛ ⊥" ..
  }
  have "\<And> n . x + S n = x ⇛ ⊥" by fact
  then have "∀(λ n . x + S n = x ⇛ ⊥)" ..
  from all_ante and this show ?thesis
    unfolding sle_def ..
qed
#+end_src

*** lemma sle_and_eq_kaboom: "x < y ⇛ x = y ⇛ ⊥"
#+begin_src isabelle
lemma sle_and_eq_kaboom: "x < y ⇛ x = y ⇛ ⊥"
proof -
  from sle_refl_kaboom have "x = y ⇛ x < y ⇛ ⊥" by (rule equals_left_rule)
  from implC and this show ?thesis ..
qed
#+end_src
*** lemma sle_trans: "x < y ⊗ y < z ⇛ x < z"
#+begin_src isabelle
lemma sle_trans: "x < y ⊗ y < z ⇛ x < z"
proof -
{ fix m
    { fix n
      from implI have
        "x + S n = y ⇛ y + S m = z ⇛ (x + S n) + S m = z" by (rule equals_left_rule)
      then have
        "x + S n = y ⇛ y + S m = z ⇛ x + S n + S m = z" by (rule eqsub_rule'[OF plus_ass])
      then have
        "x + S n = y ⇛ y + S m = z ⇛ x + S (S n + m) = z" by (rule eqsub_rule[OF plus_succ])
      from impl_eg and this have
        "x + S n = y ⇛ y + S m = z ⇛ x < z"
        unfolding sle_def
        by(rule impl_link_121)
    }
    have "\<And> n . x + S n = y ⇛ y + S m = z ⇛ x < z" by fact
    then have "∀ (λ n . x + S n = y ⇛ y + S m = z ⇛ x < z)" ..
    from all_ante and this have
      "x < y ⇛ y + S m = z ⇛ x < z"
      unfolding sle_def ..
  }
  have "\<And> m . x < y ⇛ y + S m = z ⇛ x < z" by fact
  then have "∀ (λ m . x < y ⇛ y + S m = z ⇛ x < z)" ..
  from all_cons and this have
    "x < y ⇛ ∀ (λ m . y + S m = z ⇛ x < z)" ..
  from this and all_ante have
    "x < y ⇛ y < z ⇛ x < z"
    unfolding sle_def ..
  from conj_import and this show ?thesis ..
qed
#+end_src

*** lemma self_succ_kaboom: "x = S x ⇛ ⊥"
#+begin_src isabelle
lemma self_succ_kaboom: "x = S x ⇛ ⊥"
proof -
  from sle_succ have "x = S x ⇛ x < x" by (rule equals_left_rule')
  from this and sle_refl_kaboom show ?thesis ..
qed
#+end_src

*** lemma plus_leq_monotonic_left: "x ≤ y ⇛ x + z ≤ y + z"
#+begin_src isabelle
lemma plus_leq_monotonic_left: "x ≤ y ⇛ x + z ≤ y + z"
proof -
  { fix n
    from refl have
      "x + n = y ⇛ (x + n) + z = y + z" by(rule equals_left_rule)
    then have
      "x + n = y ⇛ x + n + z = y + z" by(rule eqsub_rule'[OF plus_ass])
    then have
      "x + n = y ⇛ x + z + n = y + z" by(rule eqsub_rule[OF plus_comm])
    then have
      "x + n = y ⇛ (x + z) + n = y + z" by(rule eqsub_rule[OF plus_ass])
    from this and impl_eg have
      "x + n = y ⇛ x + z ≤ y + z"
      unfolding leq_def ..
  }
  have "\<And> n. x + n = y ⇛ x + z ≤ y + z" by fact
  then have "∀(λ n. x + n = y ⇛ x + z ≤ y + z)" ..
  from all_ante and this show ?thesis
    unfolding leq_def ..
qed
#+end_src

*** lemma plus_leq_cancel: "x + z ≤ y + z ⇛ x ≤ y"
#+begin_src isabelle
lemma plus_leq_cancel: "x + z ≤ y + z ⇛ x ≤ y"
proof -
  { fix n
    from plus_cancel have
      "x + n + z = y + z ⇛ x + n = y" by(rule eqsub_rule'[OF plus_ass])
    then have
      "x + z + n = y + z ⇛ x + n = y" by(rule eqsub_rule[OF plus_comm])
    then have
      "(x + z) + n = y + z ⇛ x + n = y" by(rule eqsub_rule[OF plus_ass])
    from this and impl_eg have
      "(x + z) + n = y + z ⇛ x ≤ y"
      unfolding leq_def ..
  }
  have "\<And> n . (x + z) + n = y + z ⇛ x ≤ y" by fact
  then have "∀(λ n . (x + z) + n = y + z ⇛ x ≤ y)" ..
  from all_ante and this show ?thesis
    unfolding leq_def ..
qed
#+end_src

*** lemma plus_sle_monotonic_left: "x < y ⇛ x + z < y + z"
#+begin_src isabelle
(* this and the next are copy/paste find/replace versions of the previous two *)
lemma plus_sle_monotonic_left: "x < y ⇛ x + z < y + z"
proof -
  { fix n
    from refl have
      "x + S n = y ⇛ (x + S n) + z = y + z" by(rule equals_left_rule)
    then have
      "x + S n = y ⇛ x + S n + z = y + z" by(rule eqsub_rule'[OF plus_ass])
    then have
      "x + S n = y ⇛ x + z + S n = y + z" by(rule eqsub_rule[OF plus_comm])
    then have
      "x + S n = y ⇛ (x + z) + S n = y + z" by(rule eqsub_rule[OF plus_ass])
    from this and impl_eg have
      "x + S n = y ⇛ x + z < y + z"
      unfolding sle_def ..
  }
  have "\<And> n. x + S n = y ⇛ x + z < y + z" by fact
  then have "∀(λ n. x + S n = y ⇛ x + z < y + z)" ..
  from all_ante and this show ?thesis
    unfolding sle_def ..
qed
#+end_src

*** lemma plus_sle_monotonic_right: "x < y ⇛ z + x < z + y"
#+begin_src isabelle
lemma plus_sle_monotonic_right: "x < y ⇛ z + x < z + y"
  apply(rule eqsub_rule[OF plus_comm[of x z]])
  apply(rule eqsub_rule[OF plus_comm[of y z]])
  apply(rule plus_sle_monotonic_left)
  done
#+end_src
*** lemma plus_sle_double_monotonic: "x < y ⊗ u < v ⇛ x + u < y + v"
#+begin_src isabelle
lemma plus_sle_double_monotonic: "x < y ⊗ u < v ⇛ x + u < y + v"
proof -
  from plus_sle_monotonic_left and plus_sle_monotonic_right have
    "x < y ⊗ u < v ⇛ x + u < y + u ⊗ y + u < y + v"
    by(rule factor_rule)
  from this and sle_trans show ?thesis ..
qed
#+end_src
*** lemma plus_sle_cancel: "x + z < y + z ⇛ x < y"
#+begin_src isabelle
lemma plus_sle_cancel: "x + z < y + z ⇛ x < y"
proof -
  { fix n
    from plus_cancel have
      "x + S n + z = y + z ⇛ x + S n = y" by(rule eqsub_rule'[OF plus_ass])
    then have
      "x + z + S n = y + z ⇛ x + S n = y" by(rule eqsub_rule[OF plus_comm])
    then have
      "(x + z) + S n = y + z ⇛ x + S n = y" by(rule eqsub_rule[OF plus_ass])
    from this and impl_eg have
      "(x + z) + S n = y + z ⇛ x < y"
      unfolding sle_def ..
  }
  have "\<And> n . (x + z) + S n = y + z ⇛ x < y" by fact
  then have "∀(λ n . (x + z) + S n = y + z ⇛ x < y)" ..
  from all_ante and this show ?thesis
    unfolding sle_def ..
qed
#+end_src




*** lemma times_leq_monotonic_left: "x ≤ y ⇛ x × z ≤ y × z"
#+begin_src isabelle
lemma times_leq_monotonic_left: "x ≤ y ⇛ x × z ≤ y × z"
proof -
  { fix n
    from refl have
      "x + n = y ⇛ (x + n) × z = y × z" by(rule equals_left_rule)
    then have
      "x + n = y ⇛ (x × z) + (n × z) = y × z" by(rule eqsub_rule[OF times_plus_dist'])
    from this and impl_eg have
      "x + n = y ⇛ x × z ≤ y × z"
      unfolding leq_def ..
  }
  have "\<And> n. x + n = y ⇛ x × z ≤ y × z" by fact
  then have "∀(λ n. x + n = y ⇛ x × z ≤ y × z)" ..
  from all_ante and this show ?thesis
    unfolding leq_def ..
qed
#+end_src

*** lemma times_sle_monotonic_left: "x < y ⇛ x × S z < y × S z"
#+begin_src isabelle
lemma times_sle_monotonic_left: "x < y ⇛ x × S z < y × S z"
proof -
  { fix n
    from refl have
      "x + S n = y ⇛ (x + S n) × S z = y × S z" by(rule equals_left_rule)
    then have
      "x + S n = y ⇛ (x × S z) + ((S n) × S z) = y × S z"
      by(rule eqsub_rule[OF times_plus_dist'])
    then have
      "x + S n = y ⇛ (x × S z) + ((S n) × z) + S n = y × S z"
      by(rule eqsub_rule[OF times_succ])
    then have
      "x + S n = y ⇛ (x × S z) + S (((S n) × z) + n) = y × S z"
      by(rule eqsub_rule[OF plus_succ])
    from this and impl_eg have
      "x + S n = y ⇛ x × S z < y × S z"
      unfolding sle_def ..
  }
  have "\<And> n. x + S n = y ⇛ x × S z < y × S z" by fact
  then have "∀(λ n. x + S n = y ⇛ x × S z < y × S z)" ..
  from all_ante and this show ?thesis
    unfolding sle_def ..
qed
#+end_src
*** lemma archimedes: "0 < n ⇛ x ≤ x × n"
#+begin_src isabelle
lemma archimedes: "0 < n ⇛ x ≤ x × n"
proof -
  from sle_refl_kaboom and efq_impl have
    "0 < 0 ⇛ x ≤ x × 0" ..
  then have
    zerohorn:"n = 0 ⇛ 0 < n ⇛ x ≤ x × n"
    by(rule equals_left_rule')

  { fix m
    from leq_plus have "x ≤ x × m + x"
      by(rule eqsub_rule[OF plus_comm])
    then have "x ≤ x × S m"
      by(rule eqsub_rule'[OF times_succ])
    from implK and this have
      "0 < n ⇛ x ≤ x × S m" ..
    then have
      "n = S m ⇛ 0 < n ⇛ x ≤ x × n"
      by(rule equals_left_rule')
  }
  have "\<And> m . n = S m ⇛ 0 < n ⇛ x ≤ x × n" by fact
  then have "∀(λ m . n = S m ⇛ 0 < n ⇛ x ≤ x × n)" ..
  from all_ante and this have
    "∃(λ m . n = S m) ⇛ 0 < n ⇛ x ≤ x × n" ..

  from zerohorn and this have
    almost:"n = 0 ∨ ∃(λ m . n = S m) ⇛ 0 < n ⇛ x ≤ x × n"
    by(rule disj_left_rule)
  from entl_ui and prop_24 have "n = 0 ∨ ∃(λ m . n = S m)" ..
  from almost and this show ?thesis ..
qed
#+end_src
*** lemma sle_succ_leq: "x < y ⇛ S x ≤ y"
#+begin_src isabelle
lemma sle_succ_leq: "x < y ⇛ S x ≤ y"
proof -
  { fix n
    from implI have "x + S n = y ⇛ S x + n = y"
      by(rule eqsub_rule[OF plus_comm_aux])
    from this and impl_eg have "x + S n = y ⇛ S x ≤ y"
      unfolding leq_def ..
  }
  have "\<And> n . x + S n = y ⇛ S x ≤ y" by fact
  then have "∀(λ n. x + S n = y ⇛ S x ≤ y)" ..
  from all_ante and this show ?thesis
    unfolding sle_def ..
qed
#+end_src
*** lemma linearity: "x ≤ y ∨ y ≤ x"
#+begin_src isabelle
lemma linearity: "x ≤ y ∨ y ≤ x"
proof -
  let ?phi = "λ u v. u ≤ v ∨ v ≤ u"
  from impl_disj_inl and zero_leq  have zerocase:"?phi 0 y" ..

  { fix x
    from sle_leq and sle_succ have start:"x ≤ S x" ..
    from impl_conj_in and this have "y ≤ x ⇛ y ≤ x ⊗ x ≤ S x" ..
    from this and leq_trans have "y ≤ x ⇛ y ≤ S x" ..
    from this and impl_disj_inr have righthorn:"y ≤ x ⇛ ?phi (S x) y" ..

    from start have "x = y ⇛ y ≤ S x" by(rule equals_left_rule)
    from this and impl_disj_inr have leftequalshorn: "x = y ⇛ ?phi (S x) y" ..
    from sle_succ_leq and impl_disj_inl have leftslehorn: "x < y ⇛ ?phi (S x) y" ..
    from leftequalshorn and leftslehorn have
      "x = y ∨ x < y ⇛ ?phi (S x) y" by(rule disj_left_rule)
    from leq_eq_or_sle and this have
      lefthorn:"x ≤ y ⇛ ?phi (S x) y" ..

    from lefthorn and righthorn have "?phi x y ⇛ ?phi (S x) y" by(rule disj_left_rule)
  }
  have "\<And> x. ?phi x y ⇛ ?phi (S x) y" by fact
  then have inductive:"∀(λ x. ?phi x y ⇛ ?phi (S x) y)" ..

  from zerocase and inductive show ?thesis by(rule induction_rule_bare)
qed
#+end_src
*** lemma trichotomy: "x < y ∨ x = y ∨ y < x"
#+begin_src isabelle
lemma trichotomy: "x < y ∨ x = y ∨ y < x"
proof -
  from leq_eq_or_sle and leq_eq_or_sle have
    "x ≤ y ∨ y ≤ x ⇛ (x = y ∨ x < y) ∨ (y = x ∨ y < x)"
    by(rule disj_factor_rule)
  from this and linearity have
    fourway:"(x = y ∨ x < y) ∨ (y = x ∨ y < x)" ..

  from implI have "y = x ⇛ x = y" by(rule bisub_rule[OF eq_sym_bientl])
  from implI and this have twotoone:"x = y ∨ y = x ⇛ x = y" by(rule disj_left_rule)

  from fourway have "(x = y ∨ y = x) ∨ (x < y ∨ y < x)"
    (* by(subdmq_normalize) *)
    apply -
    apply(rule bisub_rule'[OF disj_biass])
    apply(rule bisub_rule[OF disj_bicomm[of _ "x < y"]])
    apply(rule bisub_rule[OF disj_biass[of _ _ "x < y"]])
    apply(rule bisub_rule[OF disj_bicomm[of _ "y = x"]])
    apply(rule bisub_rule'[OF disj_biass])
    apply(rule bisub_rule[OF disj_biass])
    apply assumption
    done

  from twotoone and this have "x = y ∨ (x < y ∨ y < x)" by(rule disj_monotone_left_rule)
  from this show ?thesis
    by(subdmq_normalize)
qed
#+end_src
** Multiplicative cancellation
*** Comments
- There are some comments on showing cancellation for < rather than = on p200; these seem wrong. (The times_succ axiom is misapplied, I think?)
*** lemma times_cancel: "x × S z = y × S z ⇛ x = y"
#+begin_src isabelle
lemma times_cancel: "x × S z = y × S z ⇛ x = y"
proof -
  from efq_impl and sle_and_eq_kaboom have
    "x × S z < y × S z ⇛ x × S z = y × S z ⇛ x = y" by(rule impl_link_121)
  from times_sle_monotonic_left and this have
    firsthorn:"x < y ⇛ x × S z = y × S z ⇛ x = y" ..

  from efq_impl and sle_and_eq_kaboom have
    "y × S z < x × S z ⇛ y × S z = x × S z ⇛ x = y" by(rule impl_link_121)
  then have
    "y × S z < x × S z ⇛ x × S z = y × S z ⇛ x = y" by(rule bisub_rule[OF eq_sym_bientl])
  from times_sle_monotonic_left and this have
    thirdhorn:"y < x ⇛ x × S z = y × S z ⇛ x = y" ..

  from implK and thirdhorn have
    "x = y ∨ y < x ⇛ x × S z = y × S z ⇛ x = y" by(rule disj_left_rule)
  from firsthorn and this have
    "x < y ∨ x = y ∨ y < x ⇛ x × S z = y × S z ⇛ x = y" by(rule disj_left_rule)
  from this and trichotomy show ?thesis ..
qed
#+end_src
* End
#+begin_src isabelle
end
#+end_src
